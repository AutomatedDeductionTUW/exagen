As we alluded to in Sect.~\ref{sec:sat},
some issues may arise if the restrictions on the randomly generated formula are too strict:
\begin{itemize}
    \item
        The sample space might be empty or very sparse.
        In practice, this manifests as the generator seemingly getting stuck,
        usually resulting in the process being killed by the user.

        For example,
        consider the restriction on polarity (item~\ref{item:polarity} in Sect.~\ref{sec:sat}).
        Combined with the other restrictions,
        it is impossible to get a formula that contains atomic proposition
        of purely positive and purely negative polarity at the same time.

    \item
        The second issue manifests less drastically but is perhaps more problematic:
        the sample space may be too uniform,
        leading to the generation of boring and similar formulas.

        In particular, we encountered this problem
        when we restricted the number of models to exactly one, or zero.
        (There simply aren't that many ways to rule out 8 interpretations
        using only 7 connectives.)
\end{itemize}





Regarding the filtering discussed in Sect.~\ref{sec:satfo},
note that we did not require very efficient algorithms since
the formulas under consideration are very small.
For example, for the restriction on the number of models we used a naive satisfiability test
based on evaluating the formula under each possible interpretation.
An advantage of this is that the addition of new filters is relatively easy.





For the random generation of the SAT and redundancy problems described in Sect.~\ref{sec:satfo},
we were inspired by the Haskell library QuickCheck~\cite{ClaessenHughes:2000:QuickCheck},
which we used for the first prototype.
However, because of our many filtering criteria we wanted the generator to support backtracking.
To this end,
we created a simple mtl-style typeclass \texttt{MonadChoose}
with a single primitive operation \texttt{choose} for choosing an element from a list of possible choices.
\todo{since it's the appendix we could give some source code listings? maybe the typeclass and a snippet of the inference generator}

Our generator implementations are generic over the monad, constrained by \texttt{MonadChoose}.
We used two concrete implementations to evaluate generators:
\begin{enumerate}
    \item
        \texttt{RandomChoice}, a monad that implements \texttt{choose}
        as uniform random choice with backtracking support.
        Conceptually, this is like the standard list monad
        where \texttt{choose} works like the regular monadic bind for lists
        except that it shuffles the list with a random permutation first.
        This evaluation method is used to generate random exams.
    \item
        The standard list monad to enumerate the sample space.
        This second evaluation method lets us ensure that the sample space is sufficiently large.
\end{enumerate}
